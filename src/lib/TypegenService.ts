import { Project } from 'ts-morph';
import {
  AgentsmithSupabaseService,
  AgentsmithSupabaseServiceConstructorOptions,
} from './AgentsmithSupabaseService';
import { compareSemanticVersions } from '@/utils/versioning';

type GenerateTypesOptions = {
  projectId: number;
};

const variableTypeToTsType = (type: string) => {
  switch (type) {
    case 'STRING':
      return 'string';
    case 'NUMBER':
      return 'number';
    case 'BOOLEAN':
      return 'boolean';
    case 'JSON':
      return 'any';
    default:
      return 'any';
  }
};

const jsonToTsType = (json: any): any => {
  if (typeof json === 'string') {
    return `'${json}'`;
  }
  if (typeof json === 'object' && json !== null) {
    if (Array.isArray(json)) {
      return `[${json.map((item) => jsonToTsType(item)).join(', ')}]`;
    } else {
      const entries = Object.entries(json).map(([key, value]) => {
        const tsValue = jsonToTsType(value);
        return `'${key}': ${tsValue}`;
      });
      return `{ ${entries.join('; ')} }`;
    }
  }
  return JSON.stringify(json);
};

export class TypegenService extends AgentsmithSupabaseService {
  constructor(options: AgentsmithSupabaseServiceConstructorOptions) {
    super({
      ...options,
      serviceName: 'typegen',
    });
  }

  async generateTypes(options: GenerateTypesOptions) {
    const { projectId } = options;

    // process prompts to get the latest version and variables
    const project = new Project();
    const sourceFile = project.createSourceFile('agentsmith.types.ts', '', {
      overwrite: true,
    });

    // Add generated file header
    sourceFile.addStatements([
      '/*',
      '|--------------------------------------------|',
      '         ⚡️ Generated by Agentsmith ⚡️',
      '      ⚠️ Do not edit this file directly ⚠️',
      '|--------------------------------------------|',
      '*/',
      '',
    ]);

    // Fetch prompts from Supabase

    // fetch all prompts, prompt_versions, and prompt_variables
    const prompts = await this.services.prompts.getAllPromptsData(projectId);

    const globals = await this.services.projects.getProjectGlobalsByProjectId(projectId);

    // Process prompts to get the latest version and variables
    const processedPrompts = prompts
      .map((prompt) => {
        const versions = prompt.prompt_versions || [];
        // Sort versions by created_at in descending order
        const sortedVersions = [...versions].sort((a, b) =>
          compareSemanticVersions(b.version, a.version),
        );

        if (sortedVersions.length === 0) {
          return null;
        }

        const latestVersion = sortedVersions.find((v) => v.status === 'PUBLISHED');

        return {
          uuid: prompt.uuid,
          name: prompt.name,
          slug: prompt.slug,
          latestVersion,
          versions: sortedVersions.map((v) => ({
            uuid: v.uuid,
            version: v.version,
            config: v.config,
            content: v.content,
            status: v.status,
            variables: v.prompt_variables.map((pv) => ({
              uuid: pv.uuid,
              name: pv.name,
              type: pv.type,
              required: pv.required,
              default_value: pv.default_value,
            })),
          })),
        };
      })
      .filter((p) => p !== null);

    sourceFile.addTypeAlias({
      name: 'Agency',
      isExported: true,
      type: `{
        prompts: {
          ${processedPrompts
            .map((p) => {
              if (!p) return '';

              const versionsString = p.versions
                .map((v) => {
                  const variablesString = v.variables
                    .map(
                      (variable) =>
                        `${variable.name}${variable.required ? '' : '?'}: ${variableTypeToTsType(variable.type)}`,
                    )
                    .join('; ');
                  const versionConfig = `config: ${JSON.stringify(v.config)}`;
                  let versionObjectProperties = `uuid: '${v.uuid}'; version: '${v.version}'; ${versionConfig}; content: string`;
                  if (v.variables.length > 0) {
                    versionObjectProperties += `; variables: { ${variablesString} }`;
                  }
                  return `    '${v.version}': { ${versionObjectProperties} }`;
                })
                .join(';\n');

              const latestVersionVariables = p.latestVersion?.prompt_variables || [];
              const latestVersionVariablesString = latestVersionVariables
                .map(
                  (variable) =>
                    `'${variable.name}'${variable.required ? '' : '?'}: ${variableTypeToTsType(variable.type)}`,
                )
                .join('; ');

              let latestVersionObjectProperties = !p.latestVersion
                ? ''
                : `uuid: '${p.latestVersion.uuid}'; version: '${p.latestVersion.version}'; config: ${JSON.stringify(p.latestVersion.config)}; content: string`;
              if (latestVersionVariables.length > 0) {
                latestVersionObjectProperties += `; variables: { ${latestVersionVariablesString} }`;
              }
              const latestVersionString = !p.latestVersion
                ? 'latest: never'
                : `    latest: { ${latestVersionObjectProperties} }`;

              return `  '${p.slug}': {
    uuid: '${p.uuid}';
    name: '${p.name}';
    slug: '${p.slug}';
    versions: {
${latestVersionString};
${versionsString}
    }
  }`;
            })
            .join(';\n')}
        };
        globals: {${Object.entries(globals?.content || {})
          .map(([key, value]) => {
            if (typeof value === 'string') {
              return `    ${key}: '${value}'`;
            }
            return `    ${key}: ${value}`;
          })
          .join(';\n')}}
      }`,
    });

    // Format the source file
    sourceFile.formatText();

    return sourceFile.getFullText();
  }
}
