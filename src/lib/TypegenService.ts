import { Project } from 'ts-morph';
import {
  AgentsmithSupabaseService,
  AgentsmithSupabaseServiceConstructorOptions,
} from './AgentsmithSupabaseService';
import { compareSemanticVersions } from '@/utils/versioning';
import generateTypeDeclaration from '@/utils/object-to-declare';
import { format } from 'prettier';
import { RESERVED_KEYWORDS } from '@/constants/reserved-keywords';

type GenerateTypesOptions = {
  projectId: number;
};

export class TypegenService extends AgentsmithSupabaseService {
  constructor(options: AgentsmithSupabaseServiceConstructorOptions) {
    super({
      ...options,
      serviceName: 'typegen',
    });
  }

  private variableTypeToTsType(type: string) {
    switch (type) {
      case 'STRING':
        return 'string';
      case 'NUMBER':
        return 'number';
      case 'BOOLEAN':
        return 'boolean';
      case 'JSON':
        return 'any';
      default:
        return 'any';
    }
  }

  private _normalizeNameSegment(name: string) {
    return name.replace(/-/g, '_').replace(/\./g, '_');
  }

  private _normalizeTypeName(
    type: 'Prompt' | 'PromptVersion' | 'PromptConfig' | 'PromptVariables',
    slug: string,
    version?: string,
  ) {
    const slugSegment = this._normalizeNameSegment(slug);
    if (version) {
      const versionSegment = this._normalizeNameSegment(version);
      return `${type}__${slugSegment}__${versionSegment}`;
    }
    return `${type}__${slugSegment}`;
  }

  private _formatTypeKey(key: string) {
    const validIdentifierRegex = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;
    if (validIdentifierRegex.test(key) && !RESERVED_KEYWORDS.has(key)) {
      return key;
    }
    return `'${key}'`;
  }

  async generateTypes(options: GenerateTypesOptions) {
    const { projectId } = options;

    const project = new Project();
    const sourceFile = project.createSourceFile('agentsmith.types.ts', '', {
      overwrite: true,
    });

    // Add generated file header
    sourceFile.addStatements([
      '/*',
      '|--------------------------------------------|',
      '         ⚡️ Generated by Agentsmith ⚡️',
      '      ⚠️ Do not edit this file directly ⚠️',
      '|--------------------------------------------|',
      '*/',
      '',
    ]);

    // Fetch prompts from Supabase
    const allPromptsData = await this.services.prompts.getAllPromptsData(projectId);

    const projectGlobals = await this.services.projects.getProjectGlobalsByProjectId(projectId);

    const prompts = allPromptsData.sort((a, b) => a.slug.localeCompare(b.slug));

    // First pass: Generate all variable types
    for (const prompt of prompts) {
      const promptVersions = prompt.prompt_versions.sort((a, b) =>
        compareSemanticVersions(b.version, a.version),
      );

      for (const version of promptVersions) {
        const variablesTypeName = this._normalizeTypeName(
          'PromptVariables',
          prompt.slug,
          version.version,
        );
        sourceFile.addTypeAlias({
          name: variablesTypeName,
          isExported: true,
          type: (writer) => {
            if (version.prompt_variables.length === 0) {
              writer.write('never');
              return;
            }
            writer.block(() => {
              for (const variable of version.prompt_variables) {
                writer.writeLine(
                  `${this._formatTypeKey(variable.name)}${
                    variable.required ? '' : '?'
                  }: ${this.variableTypeToTsType(variable.type)};`,
                );
              }
            });
          },
        });
        sourceFile.addStatements('\n\n');
      }
    }

    // Second pass: Generate all other types
    for (const prompt of prompts) {
      const promptVersions = prompt.prompt_versions.sort((a, b) =>
        compareSemanticVersions(b.version, a.version),
      );

      for (const version of promptVersions) {
        // Create a dedicated type for the config
        const configTypeName = this._normalizeTypeName(
          'PromptConfig',
          prompt.slug,
          version.version,
        );

        const configType = generateTypeDeclaration(version.config, {
          rootName: configTypeName,
        }).replace(`interface ${configTypeName}`, '');

        sourceFile.addTypeAlias({
          name: configTypeName,
          isExported: true,
          type: configType,
        });
        sourceFile.addStatements('\n\n');

        const typeName = this._normalizeTypeName('PromptVersion', prompt.slug, version.version);
        sourceFile.addTypeAlias({
          name: typeName,
          isExported: true,
          type: (writer) => {
            writer.block(() => {
              writer.writeLine(`version: '${version.version}';`);
              writer.writeLine(`config: ${configTypeName};`);
              writer.writeLine(`type: '${version.type}';`);

              const variableTypeNames = [];
              const ownVariablesTypeName = this._normalizeTypeName(
                'PromptVariables',
                prompt.slug,
                version.version,
              );
              variableTypeNames.push(ownVariablesTypeName);

              if (version.prompt_includes && version.prompt_includes.length > 0) {
                for (const include of version.prompt_includes) {
                  if (include.prompt_versions.prompt_variables.length > 0) {
                    const includedVariablesTypeName = this._normalizeTypeName(
                      'PromptVariables',
                      include.prompt_versions.prompts.slug,
                      include.prompt_versions.version,
                    );
                    variableTypeNames.push(includedVariablesTypeName);
                  }
                }
              }

              writer.writeLine(`variables: ${variableTypeNames.join(' & ')};`);
              writer.writeLine(`content: string;`);
            });
          },
        });
        sourceFile.addStatements('\n\n');
      }

      const typeName = this._normalizeTypeName('Prompt', prompt.slug);
      sourceFile.addTypeAlias({
        name: typeName,
        isExported: true,
        type: (writer) => {
          writer.block(() => {
            writer.writeLine(`name: '${prompt.name}';`);
            writer.writeLine(`slug: '${prompt.slug}';`);
            writer.write('versions: ').block(() => {
              const latestVersion = (prompt.prompt_versions || [])
                .filter((v) => v.status === 'PUBLISHED')
                .sort((a, b) => compareSemanticVersions(b.version, a.version))[0];

              if (latestVersion) {
                const latestVersionTypeName = this._normalizeTypeName(
                  'PromptVersion',
                  prompt.slug,
                  latestVersion.version,
                );
                writer.writeLine(`latest: ${latestVersionTypeName};`);
              } else {
                writer.writeLine('latest: never;');
              }

              for (const version of prompt.prompt_versions) {
                const versionTypeName = this._normalizeTypeName(
                  'PromptVersion',
                  prompt.slug,
                  version.version,
                );
                writer.writeLine(`'${version.version}': ${versionTypeName};`);
              }
            });
          });
        },
      });
      sourceFile.addStatements('\n\n');
    }

    const globalsContent = projectGlobals?.content || {};

    const globalsType = generateTypeDeclaration(globalsContent, {
      rootName: 'Globals',
    }).replace(`interface Globals`, '');
    sourceFile.addTypeAlias({
      name: 'Globals',
      isExported: true,
      type: globalsType,
    });

    sourceFile.addTypeAlias({
      name: 'Agency',
      isExported: true,
      type: (writer) => {
        writer.block(() => {
          writer.write('prompts: ').block(() => {
            for (const prompt of prompts) {
              const typeName = this._normalizeTypeName('Prompt', prompt.slug);
              writer.writeLine(`${this._formatTypeKey(prompt.slug)}: ${typeName};`);
            }
          });
          writer.writeLine(`globals: Globals;`);
        });
      },
    });

    const unformattedText = sourceFile.getFullText();

    return format(unformattedText, {
      parser: 'typescript',
      singleQuote: true,
      trailingComma: 'all',
      printWidth: 100,
      tabWidth: 2,
      useTabs: false,
      semi: true,
    });
  }
}
