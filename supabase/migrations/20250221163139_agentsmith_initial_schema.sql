-- Enable the "pgtap" extension
create extension pgtap with schema extensions;

-- Enums
create type organization_tier as enum ('FREE', 'PRO', 'ENTERPRISE');
create type prompt_status as enum ('DRAFT', 'PUBLISHED', 'ARCHIVED');
create type variable_type as enum ('STRING', 'NUMBER', 'BOOLEAN', 'JSON');
create type organization_user_role as enum ('ADMIN', 'MEMBER');

-- Functions
create or replace function set_updated_at()
returns trigger
language plpgsql
security definer
set search_path = ''
as $$
begin
    new.updated_at = now();
    return new;
end;
$$;

-- Agentsmith Users
create table agentsmith_users (
    id bigint generated by default as identity not null primary key,
    auth_user_id uuid references auth.users(id) not null,
    email text,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);

create index on agentsmith_users(auth_user_id);
create index on agentsmith_users(created_at);
create index on agentsmith_users(updated_at);

alter table agentsmith_users enable row level security;

create or replace function agentsmith_user_id()
returns bigint
language sql
security definer
set search_path = ''
as $$
  select id from public.agentsmith_users
  where auth_user_id = (select auth.uid());
$$;

create policy "Users can view their own record"
    on agentsmith_users for select
    to authenticated
    using (auth_user_id = (SELECT auth.uid()));

create trigger trigger_updated_at_agentsmith_users
    before update on agentsmith_users
    for each row
    execute function set_updated_at();

create or replace function gen_invite_code()
returns text
language plpgsql
security definer
set search_path = ''
as $$
declare
  var_invite_code text;
begin
    -- generate string of 6 random uppercase alphanumeric characters
    select upper(substr(md5(random()::text), 1, 6)) into var_invite_code;

    -- we continuously check if the invite code already exists until we find one that doesn't
    while exists (select 1 from public.organizations where invite_code = var_invite_code) loop
        select upper(substr(md5(random()::text), 1, 6)) into var_invite_code;
    end loop;

    -- once we find an invite code that doesn't exist, we return it
    return var_invite_code;
end;
$$;


-- Organizations
create table organizations (
    id bigint generated by default as identity not null primary key,
    uuid uuid not null unique default uuid_generate_v4(),
    name text not null,
    invite_code text not null unique,
    tier organization_tier not null default 'FREE',
    created_by bigint references agentsmith_users(id) not null,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);

create index on organizations(tier);
create index on organizations(created_at);
create index on organizations(updated_at);

alter table organizations enable row level security;
alter table organizations alter column invite_code set default gen_invite_code();

create trigger trigger_updated_at_organizations
    before update on organizations
    for each row
    execute function set_updated_at();

create or replace function join_organization(arg_invite_code text)
returns uuid
language plpgsql
security definer
set search_path = ''
as $$
declare
  var_organization_uuid uuid;
  var_organization_id bigint;
begin
    -- get the organization id, and the uuid from the invite code
    select id, uuid into var_organization_id, var_organization_uuid
    from public.organizations
    where invite_code = arg_invite_code;

    -- verify the organization exists
    if var_organization_id is null then
        raise exception 'Organization not found';
    end if;

    -- verify the user is not already a member of the organization
    if exists (select 1 from public.organization_users ou
        where ou.organization_id = var_organization_id
        and ou.user_id = public.agentsmith_user_id())
    then
        raise exception 'User is already a member of this organization';
    end if;

    -- add the user to the organization
    insert into public.organization_users (organization_id, user_id, role)
    values (var_organization_id, public.agentsmith_user_id(), 'MEMBER');

    return var_organization_uuid;
end;
$$;


create table organization_users (
    id bigint generated by default as identity not null primary key,
    organization_id bigint references organizations(id) not null,
    user_id bigint references agentsmith_users(id) not null,
    role organization_user_role not null,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now(),
    unique (organization_id, user_id)
);

create index on organization_users(organization_id);
create index on organization_users(user_id);
create index on organization_users(role);
create index on organization_users(created_at);

alter table organization_users enable row level security;

create or replace function is_organization_member(org_id bigint)
returns boolean
language sql
security definer
set search_path = ''
as $$
  select exists (
    select 1 from public.organization_users ou
    where ou.organization_id = org_id
    and ou.user_id = public.agentsmith_user_id()
  );
$$;

create or replace function is_organization_admin(org_id bigint)
returns boolean
language sql
security definer
set search_path = ''
as $$
  select exists (
    select 1 from public.organization_users
    where organization_id = org_id
    and user_id = public.agentsmith_user_id()
    and role = 'ADMIN'
  );
$$;

create policy "organization users select"
    on organization_users for select
    to authenticated
    using (is_organization_member(organization_id));

create policy "organization users insert"
    on organization_users for insert
    to authenticated
    with check (is_organization_admin(organization_id));

create policy "organization users update"
    on organization_users for update
    to authenticated
    using (is_organization_admin(organization_id));

create policy "organization users delete"
    on organization_users for delete
    to authenticated
    using (is_organization_admin(organization_id));

create policy "Users can view organizations they are members of"
    on organizations for select
    to authenticated
    using (is_organization_member(id));

create policy "Users can view organization members if they are a member"
    on organization_users for select
    to authenticated
    using (is_organization_member(organization_id));

create trigger trigger_updated_at_organization_users
    before update on organization_users
    for each row
    execute function set_updated_at();

create or replace function create_organization(arg_name text)
returns uuid
language plpgsql
security definer
set search_path = ''
as $$
declare
  var_organization_uuid uuid;
  var_organization_id bigint;
begin
    -- create the organization
    insert into public.organizations (name, created_by)
    values (arg_name, public.agentsmith_user_id())
    returning id, uuid into var_organization_id, var_organization_uuid;

    -- create an admin user for the organization
    insert into public.organization_users (organization_id, user_id, role)
    values (var_organization_id, public.agentsmith_user_id(), 'ADMIN');

    -- create a default project for the organization
    insert into public.projects (organization_id, name, created_by)
    values (var_organization_id, 'Default Project', public.agentsmith_user_id());

    return var_organization_uuid;
end;
$$;

create or replace function rename_organization(arg_organization_uuid uuid, arg_name text)
returns void
language plpgsql
security definer
set search_path = ''
as $$
declare
  var_organization_id bigint;
begin
    -- get the organization id from the uuid
    select id into var_organization_id
    from public.organizations
    where uuid = arg_organization_uuid;

    -- verify user is an admin of the organization
    if not public.is_organization_admin(var_organization_id) then
        raise exception 'User is not an organization admin';
    end if;

    update public.organizations
    set name = arg_name
    where id = var_organization_id;
end;
$$;

-- Projects
create table projects (
    id bigint generated by default as identity not null primary key,
    uuid uuid not null unique default uuid_generate_v4(),
    name text not null,
    organization_id bigint references organizations(id) not null,
    created_by bigint references agentsmith_users(id) not null,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);

create index on projects(organization_id);
create index on projects(created_by);
create index on projects(created_at);

alter table projects enable row level security;

create or replace function has_project_access(proj_id bigint)
returns boolean
language sql
security definer
set search_path = ''
as $$
  select exists (
    select 1 from public.projects p
    join public.organization_users ou on ou.organization_id = p.organization_id
    where p.id = proj_id
    and ou.user_id = public.agentsmith_user_id()
  );
$$;

create policy "Users can view projects they have access to"
    on projects for select
    to authenticated
    using (has_project_access(id));

create policy "Organization admins can create projects"
    on projects for insert
    to authenticated
    with check (is_organization_admin(organization_id));

create policy "Organization admins can update projects"
    on projects for update
    to authenticated
    using (is_organization_admin(organization_id));

create policy "Organization admins can delete projects"
    on projects for delete
    to authenticated
    using (is_organization_admin(organization_id));

create trigger trigger_updated_at_projects
    before update on projects
    for each row
    execute function set_updated_at();

-- Auto-create agentsmith_users record, default organization, and default project when auth.users record is created
create or replace function create_agentsmith_user()
returns trigger
language plpgsql
security definer
set search_path = ''
as $$
declare
  var_agentsmith_user_id bigint;
  var_organization_id bigint;
begin
    -- create the agentsmith_users record
    insert into public.agentsmith_users (auth_user_id, email)
    values (new.id, new.email)
    returning id into var_agentsmith_user_id;

    -- create the default organization
    insert into public.organizations (name, tier, created_by)
    values ('Default Organization', 'FREE', var_agentsmith_user_id)
    returning id into var_organization_id;

    -- create the default organization user
    insert into public.organization_users (organization_id, user_id, role)
    values (var_organization_id, var_agentsmith_user_id, 'ADMIN');

    -- create the default project
    insert into public.projects (organization_id, name, created_by)
    values (var_organization_id, 'Default Project', var_agentsmith_user_id);

    return new;
end;
$$;

create trigger trigger_create_agentsmith_user
    after insert on auth.users
    for each row
    execute function create_agentsmith_user();


-- Organization Keys
create table organization_keys (
    id bigint generated by default as identity not null primary key,
    organization_id bigint references organizations(id) not null,
    key text not null,
    key_hash text not null,
    vault_secret_id uuid references vault.secrets(id) not null,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);

create index on organization_keys(organization_id);
create index on organization_keys(vault_secret_id);
create index on organization_keys(created_at);
create index on organization_keys(updated_at);
create index on organization_keys(key);
create index on organization_keys(key_hash);
create unique index on organization_keys(organization_id, key);

alter table organization_keys enable row level security;

-- RLS policies for organization_keys
create policy "Organization members can view organization keys"
    on organization_keys for select
    to authenticated
    using (is_organization_member(organization_id));

create policy "Organization admins can create organization keys"
    on organization_keys for insert
    to authenticated
    with check (is_organization_admin(organization_id));

create policy "Organization admins can delete organization keys"
    on organization_keys for delete
    to authenticated
    using (is_organization_admin(organization_id));

create trigger trigger_updated_at_organization_keys
    before update on organization_keys
    for each row
    execute function set_updated_at();

-- Global Contexts
create table global_contexts (
    id bigint generated by default as identity not null primary key,
    project_id bigint references projects(id),
    content jsonb not null,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);

create index on global_contexts(project_id);
create index on global_contexts(created_at);
create index on global_contexts(updated_at);

alter table global_contexts enable row level security;

create policy "Users can view global contexts they have access to"
    on global_contexts for select
    to authenticated
    using (has_project_access(project_id));

create policy "Users can update global contexts they have access to"
    on global_contexts for update
    to authenticated
    using (has_project_access(project_id));

create policy "Admins can delete global contexts they have access to"
    on global_contexts for delete
    to authenticated
    using (
        has_project_access(project_id) and 
        is_organization_admin((select organization_id from projects where id = project_id))
    );


create trigger trigger_updated_at_global_contexts
    before update on global_contexts
    for each row
    execute function set_updated_at();

-- Prompts
create table prompts (
    id bigint generated by default as identity not null primary key,
    uuid uuid not null unique default uuid_generate_v4(),
    project_id bigint references projects(id) not null,
    name text not null,
    slug text not null,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now(),
    unique(project_id, slug)
);

create index on prompts(project_id);
create index on prompts(created_at);
create index on prompts(updated_at);

alter table prompts enable row level security;

create or replace function has_prompt_access(prompt_id bigint)
returns boolean
language sql
security definer
set search_path = ''
as $$
  select exists (
    select 1 from public.prompts pr
    join public.projects p on p.id = pr.project_id
    join public.organization_users ou on ou.organization_id = p.organization_id
    where pr.id = prompt_id
    and ou.user_id = public.agentsmith_user_id()
  );
$$;

create policy "Users can view prompts they have access to"
    on prompts for select
    to authenticated
    using (has_project_access(project_id));

create policy "Users can create prompts in projects they have access to"
    on prompts for insert
    to authenticated
    with check (has_project_access(project_id));

create policy "Users can update prompts they have access to"
    on prompts for update
    to authenticated
    using (has_project_access(project_id));

create policy "Users can delete prompts they have access to"
    on prompts for delete
    to authenticated
    using (has_project_access(project_id));

create trigger trigger_updated_at_prompts
    before update on prompts
    for each row
    execute function set_updated_at();

-- Prompt Versions
create table prompt_versions (
    id bigint generated by default as identity not null primary key,
    uuid uuid not null unique default uuid_generate_v4(),
    prompt_id bigint references prompts(id) not null,
    config jsonb not null,
    content text not null,
    version text not null check (version ~ E'^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$'),
    status prompt_status not null,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);

create index on prompt_versions(version);
create index on prompt_versions(prompt_id);
create index on prompt_versions(created_at);
create index on prompt_versions(updated_at);

alter table prompt_versions enable row level security;

create policy "Users can view prompt versions they have access to"
    on prompt_versions for select
    to authenticated
    using (has_prompt_access(prompt_id));

create policy "Users can create prompt versions they have access to"
    on prompt_versions for insert
    to authenticated
    with check (has_prompt_access(prompt_id));

create policy "Users can update prompt versions they have access to"
    on prompt_versions for update
    to authenticated
    using (has_prompt_access(prompt_id));

create policy "Users can delete prompt versions they have access to"
    on prompt_versions for delete
    to authenticated
    using (has_prompt_access(prompt_id));

create trigger trigger_updated_at_prompt_versions
    before update on prompt_versions
    for each row
    execute function set_updated_at();

-- Prompt Variables
create table prompt_variables (
    id bigint generated by default as identity not null primary key,
    prompt_version_id bigint references prompt_versions(id),
    name text not null,
    type variable_type not null,
    required boolean not null,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);

create index on prompt_variables(prompt_version_id);

alter table prompt_variables enable row level security;

create policy "Users can view prompt variables they have access to"
    on prompt_variables for select
    to authenticated
    using (exists (
        select 1 from prompt_versions pv
        where pv.id = prompt_version_id
        and has_prompt_access(pv.prompt_id)
    ));

create policy "Users can create prompt variables they have access to"
    on prompt_variables for insert
    to authenticated
    with check (exists (
        select 1 from prompt_versions pv
        where pv.id = prompt_version_id
        and has_prompt_access(pv.prompt_id)
    ));

create policy "Users can update prompt variables they have access to"
    on prompt_variables for update
    to authenticated
    using (exists (
        select 1 from prompt_versions pv
        where pv.id = prompt_version_id
        and has_prompt_access(pv.prompt_id)
    ));

create policy "Users can delete prompt variables they have access to"
    on prompt_variables for delete
    to authenticated
    using (exists (
        select 1 from prompt_versions pv
        where pv.id = prompt_version_id
        and has_prompt_access(pv.prompt_id)
    ));

create trigger trigger_updated_at_prompt_variables
    before update on prompt_variables
    for each row
    execute function set_updated_at();

-- Organization Key RPC Functions
create or replace function get_organization_vault_secret(arg_vault_secret_id uuid)
returns jsonb
language plpgsql
security definer
set search_path = ''
as $$
declare
  var_result jsonb;
  var_secret_text text;
  var_auth_uid uuid;
begin
  -- get the current authenticated user
  var_auth_uid := (select auth.uid());
  
  -- only return the secret if the user is a member of the organization that owns it
  select s.decrypted_secret into var_secret_text
  from vault.decrypted_secrets s
  join public.organization_keys ok on ok.vault_secret_id = s.id
  join public.organization_users ou on ou.organization_id = ok.organization_id
  join public.agentsmith_users au on ou.user_id = au.id
  where s.id = arg_vault_secret_id
    and au.auth_user_id = var_auth_uid;
    
  -- convert the text to jsonb - handle null case
  if var_secret_text is not null then
    var_result := jsonb_build_object('value', var_secret_text);
  end if;
  
  return var_result;
end;
$$;

-- create rpc function to create an organization key and vault entry
create or replace function create_organization_key(
  arg_organization_uuid uuid,
  arg_key text,
  arg_value text,
  arg_description text default null
)
returns jsonb
language plpgsql
security definer
set search_path = ''
as $$
declare
  var_new_vault_secret_id uuid;
  var_auth_uid uuid;
  var_organization_id bigint;
  var_key_hash text;
begin
  -- get the current authenticated user
  var_auth_uid := (select auth.uid());

  -- get the organization id from the uuid
  select o.id into var_organization_id
  from public.organizations o
  where o.uuid = arg_organization_uuid;
  
  -- verify user is an admin of the organization
  if not public.is_organization_admin(var_organization_id) then
    return jsonb_build_object('success', false, 'error', 'user is not an organization admin');
  end if;
  
  -- first create the vault entry
  insert into vault.secrets (secret, name, description)
  values (arg_value, concat(arg_key, '__org__', arg_organization_uuid), arg_description)
  returning id into var_new_vault_secret_id;

  -- hash the key
  var_key_hash := encode(extensions.digest(arg_key, 'sha256'), 'hex');
  
  -- now create the organization_key entry
  insert into public.organization_keys (organization_id, key, vault_secret_id, key_hash)
  values (var_organization_id, arg_key, var_new_vault_secret_id, var_key_hash);
  
  return jsonb_build_object('success', true, 'vault_secret_id', var_new_vault_secret_id);
end;
$$;

-- create rpc function to delete an organization key
create or replace function delete_organization_key(
  arg_organization_uuid uuid,
  arg_key_name text
)
returns jsonb
language plpgsql
security definer
set search_path = ''
as $$
declare
  var_vault_secret_id uuid;
  var_auth_uid uuid;
  var_organization_id bigint;
begin
  -- get the current authenticated user
  var_auth_uid := (select auth.uid());

  -- get the organization id from the uuid
  select o.id into var_organization_id
  from public.organizations o
  where o.uuid = arg_organization_uuid;
  
  -- verify user is an admin of the organization
  if not public.is_organization_admin(var_organization_id) then
    return jsonb_build_object('success', false, 'error', 'user is not an organization admin');
  end if;
  
  -- get the vault id for this key
  select ok.vault_secret_id into var_vault_secret_id
  from public.organization_keys ok
  where ok.organization_id = var_organization_id and ok.key = arg_key_name;
  
  if var_vault_secret_id is null then
    -- key doesn't exist, nothing to delete
    return jsonb_build_object('success', true, 'message', 'key not found, nothing to delete');
  end if;
  
  -- delete the organization key
  delete from public.organization_keys
  where organization_id = var_organization_id and key = arg_key_name;
  
  -- delete the vault entry
  delete from vault.secrets
  where id = var_vault_secret_id;
  
  return jsonb_build_object('success', true);
end;
$$;

-- TimescaleDB Extension
create extension if not exists timescaledb schema extensions;

-- LLM Logs (TimescaleDB Table)
create table llm_logs (
    id bigint generated by default as identity not null,
    uuid uuid not null default uuid_generate_v4(),
    project_id bigint references projects(id) not null,
    prompt_version_id bigint references prompt_versions(id) not null,
    prompt_variables jsonb not null,
    raw_input jsonb not null,
    raw_output jsonb,
    start_time timestamptz not null,
    end_time timestamptz,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now(),
    unique(id, created_at),
    unique(uuid, created_at)
);

create index on llm_logs(project_id, created_at);
create index on llm_logs(prompt_version_id, created_at);
create index on llm_logs(start_time, created_at);
create index on llm_logs(end_time, created_at);

create trigger trigger_updated_at_llm_logs
    before update on llm_logs
    for each row
    execute function set_updated_at();

-- Enable Row Level Security
alter table llm_logs enable row level security;

-- Create policy for read operations
create policy llm_logs_project_access_policy
    on llm_logs
    for select
    to authenticated
    using (has_project_access(project_id));

-- Create policy for insert operations
create policy llm_logs_project_insert_policy
    on llm_logs
    for insert
    to authenticated
    with check (has_project_access(project_id));

-- Create policy for update operations
create policy llm_logs_project_update_policy
    on llm_logs
    for update
    to authenticated
    using (has_project_access(project_id))
    with check (has_project_access(project_id));

-- Create policy for delete operations (explicitly deny all deletes)
create policy llm_logs_project_delete_policy
    on llm_logs
    for delete
    to authenticated
    using (false);

select create_hypertable('llm_logs', 'created_at');

create or replace function is_member_of_same_org(agentsmith_user_id bigint)
returns boolean
language sql
security definer
set search_path = ''
as $$
select exists (
    select 1 from public.organization_users ou
    where ou.user_id = agentsmith_user_id
    and public.is_organization_member(ou.organization_id)
);
$$;

create policy "Users can view agentsmith_users records if they are in the same organization"
    on agentsmith_users for select
    to authenticated
    using (is_member_of_same_org(id));

-- Generate random alphanumeric string of specified length
create or replace function gen_random_alphanumeric(length integer)
returns text
language plpgsql
security definer
set search_path = ''
as $$
declare
    chars text := 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    result text := '';
    i integer := 0;
begin
    if length < 0 then
        raise exception 'Negative string length not allowed';
    end if;
    
    for i in 1..length loop
        result := result || substr(chars, floor(random() * 62)::integer + 1, 1);
    end loop;
    
    return result;
end;
$$;

-- create function to generate api key for new organizations
create or replace function generate_organization_api_key()
returns trigger
language plpgsql
security definer
set search_path = ''
as $$
declare
  var_new_vault_secret_id uuid;
  var_api_key text;
  var_api_key_hash text;
begin
  -- generate a random api key with prefix
  var_api_key := 'sdk_' || public.gen_random_alphanumeric(32);

  -- hash the api key
  var_api_key_hash := encode(extensions.digest(var_api_key, 'sha256'), 'hex');
  
  -- create the vault entry
  insert into vault.secrets (secret, name, description)
  values (
    var_api_key, 
    'SDK_API_KEY__org__' || new.uuid, 
    'SDK API Key for organization ' || new.uuid
  )
  returning id into var_new_vault_secret_id;
  
  -- create the organization_key entry
  insert into public.organization_keys (organization_id, key, vault_secret_id, key_hash)
  values (new.id, 'SDK_API_KEY', var_new_vault_secret_id, var_api_key_hash);
  
  return new;
end;
$$;

create trigger trigger_generate_api_key
after insert on organizations
for each row
execute function generate_organization_api_key();

create or replace function get_organization_by_api_key_hash(arg_api_key_hash text)
returns jsonb
language plpgsql
security definer
set search_path = ''
as $$
declare
  var_result jsonb;
begin
  -- look up organization by api key hash
  select 
    jsonb_build_object(
      'organization_id', o.id,
      'organization_uuid', o.uuid,
      'user_id', au.id,
      'auth_user_id', au.auth_user_id,
      'email', au.email
    ) into var_result
  from public.organization_keys ok
  join public.organizations o on ok.organization_id = o.id
  join public.agentsmith_users au on o.created_by = au.id
  where ok.key_hash = arg_api_key_hash
    and ok.key = 'SDK_API_KEY';
    
  -- check if we found a result and raise exception if not
  if var_result is null then
    raise exception 'invalid api key';
  end if;
  
  return var_result;
end;
$$;

create table github_app_installations (
    id bigint generated by default as identity not null primary key,
    organization_id bigint references organizations(id) not null,
    github_account_id bigint not null,
    installation_id bigint not null,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now(),
    unique(organization_id, installation_id)
);

create index on github_app_installations(organization_id);
create index on github_app_installations(github_account_id);
create index on github_app_installations(installation_id);
create index on github_app_installations(created_at);

alter table github_app_installations enable row level security;

create policy "Users can view github app installations they have access to"
    on github_app_installations for select
    to authenticated
    using (is_organization_member(organization_id));

create policy "Organization admins can update github app installations for their organization"
    on github_app_installations for update
    to authenticated
    using (is_organization_admin(organization_id));

create policy "Organization admins can delete github app installations for their organization"
    on github_app_installations for delete
    to authenticated
    using (is_organization_admin(organization_id));

create policy "Organization admins can create github app installations for their organization"
    on github_app_installations for insert
    to authenticated
    with check (is_organization_admin(organization_id));

create trigger trigger_updated_at_github_app_installations
    before update on github_app_installations
    for each row
    execute function set_updated_at();

create table project_repositories (
    id bigint generated by default as identity not null primary key,
    project_id bigint references projects(id) not null,
    organization_id bigint references organizations(id) not null,
    github_app_installation_id bigint references github_app_installations(id) not null,
    agentsmith_folder text not null,
    repository_id bigint not null,
    repository_name text not null,
    repository_full_name text not null,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now(),
    unique(project_id, repository_id)
);

create index on project_repositories(project_id);
create index on project_repositories(organization_id);
create index on project_repositories(github_app_installation_id);
create index on project_repositories(repository_id);
create index on project_repositories(created_at);

alter table project_repositories enable row level security;

create policy "Users can view project repositories they have access to"
    on project_repositories for select
    to authenticated
    using (has_project_access(project_id));

create policy "Organization admins can update project repositories they have access to"
    on project_repositories for update
    to authenticated
    using (is_organization_admin(organization_id));

create policy "Organization admins can delete project repositories they have access to"
    on project_repositories for delete
    to authenticated
    using (is_organization_admin(organization_id));

create policy "Organization admins can create project repositories for their organization"
    on project_repositories for insert
    to authenticated
    with check (is_organization_admin(organization_id));

create trigger trigger_updated_at_project_repositories
    before update on project_repositories
    for each row
    execute function set_updated_at();